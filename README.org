* kons-9-addons

Some experiments and functions upon kons-9. As I have not completed the tour of kons-9 (and ignore most of it) what is this section may be completely useless. With time I found that some functions that appear here already exists in kons-9.

* Utilities
** The λ macro
I use this λ macro everywere:
#+begin_src lisp
;; to use λ in emacs: (define-key key-translation-map (kbd "C-c l") (kbd "λ"))
(defmacro λ (lambda-list &body code) 
  `(function (lambda ,lambda-list ,@code)))
#+end_src

** ~GET-SHAPE~ 
Given a scene groups hierarchy and a name, returns the corresponding shape. It may be used to get a shape for inspection.

#+begin_src lisp
  (defgeneric get-shape (name scene-or-group)
  (:documentation
   "Given a scene and a name, returns the shape with that name if it exists.")
  (:method ((name symbol) (a-scene scene))
    (get-shape name (shape-root a-scene)))
  (:method ((name symbol) (group shape-group))
    (loop
      with found = nil
      for c across (children group)
      while (not found)
      do
         (cond ((and (subtypep (type-of c) 'scene-item)
                     (eq (name c) name))
                (setq found c))
               ((subtypep (type-of c) 'shape-group)
                (setq found (get-shape name c))))
      finally (return found))))
#+end_src

** ~APPLY-TRANSFORM~
Applies a transfom to a shape. Kons-9 stores the shape original set points in the instance and a transform slot is the transformation (location, rotation & size) that must be applied to obtain the desired object. The transform is automatically applied before rendering. In some cases it is useful to make some computations in function of transformed points coordinates. The ~APPLY-TRANSFORM~ function computes transformed points and resets the transform. If shape is a polyhedron an after method re-computes normals.
#+begin_src lisp
(defmethod apply-transform ((s shape) &optional transform)
  "Apply a transform to a shape (updates its points) according to the 
     transform TRANSFORM or to its own transform. In the later case, 
     shape's transform is reseted."
  (let ((transf (or transform (transform s))))
    (loop
      for i below (length (points s))
      for p in (loop
                 with matrix = (transform-matrix transf)
                 for p across (points s)
                 collect (transform-point p matrix))
      do (setf (aref (points s) i) p))
    (unless transform
      ;; when transform belongs to shape. reset it.
      (reset-transform transf))
    s))
#+end_src

** Dealing with the viewport 
*** Functions to show/hide elements on the scene

Taking adavantage of the special variables that define the visibility of scene elements or the way shapes are displayed we ca define show/hide functions. Since these definitions are repetitive let's do it with a macro:
#+begin_src lisp
(defmacro make-show-hide-function (v n)
    (let ((show-f (intern (strcat "SHOW-" (symbol-name n))))
          (hide-f (intern (strcat "HIDE-" (symbol-name n)))))
      `(progn (defun ,show-f () (setq ,v t))
              (defun ,hide-f () (setq ,v nil)))))

(eval-when (:load-toplevel :compile-toplevel)
  (loop
    for (special-v name) in '((*display-filled?* faces)
                              (*display-wireframe?* wireframe)
                              (*display-points?* points)
                              (*display-ground-plane?* ground)
                              (*display-axes?* axes))
    do (eval `(make-show-hide-function ,special-v ,name))))
#+end_src

Now we can use ~(hide-faces)~, ~(hide-axes)~, ~(hide-points)~, ~(hide-wireframe)~ or ~(hide-ground~) to hide elements and the corresponding show functions to show them.

*** Changing the point of view

While it is easy to change the point of view using the mouse, it is difficult to recover a given point of view or set it precisely. Let's define the ~def-viewpoint~ macro:

#+begin_src lisp
(defmacro def-viewpoint (name &key x-rot y-rot side-dist up-dist fwd-dist)
  `(defun ,name ()
     (setq *cam-x-rot* ,(or x-rot *cam-x-rot*)
           *cam-y-rot* ,(or y-rot *cam-y-rot*)
           *cam-side-dist* ,(or side-dist *cam-side-dist*)
           *cam-up-dist* ,(or up-dist *cam-up-dist*)
           *cam-fwd-dist* ,(or fwd-dist *cam-fwd-dist*))
     t))  
#+end_src

This macro defines a function that position the camera. It may be used without parameters, for eaxmple after setting the desired positions using the mouse it can be memorized using:
#+begin_src lisp
(def-viewpoint favorite-viewpoint)
#+end_src
Memorize the current configuration that can be recovered using the newly defined ~FAVORITE-VIEWPOINT~ function. Another example may be a top-viewpoint:
#+begin_src lisp
(def-viewpoint top-viewpoint  :up-dist 0 :fwd-dist -10 :x-rot 90 :y-rot 0
               :side-dist 0 :up-dist 0)  
#+end_src
which defines the ~top-viewpoint~ function.

* About points

- The method ~IS-POINT-IN-POLYGON?~ ~(points point)~ returns ~T~ if ~POINT~ is in the polygon formed by ~POINTS and ~NIL~ otherwise. ~POINTS~ may be a list of points, a vector of points or a instance of curve. The points must be in the XY plane.

- The method ~IS-POINT-IN-POLYGON?*~ does the same but point must be co-planar (not necessarily in XY plane).
  

* About curves

- The ~INSERT-CURVE~ ~(c1 c2 where)~ method replace a point in ~C1~ by ~C2~'s sequence of points. The paramter ~WHERE~ may be a integer or a point (that must exist in ~C1~). The modified curve s returned.

- The ~REVERSE-CURVE-POINTS~ method reverse the order of points in a curve re returns the modified curve.

- Function ~MAKE-ROUNDED-RECTANGLE-CURVE~ ~(width height radius)~ makes ...
   
